#include <rtai_mbx.h>
#include <rtai_sched.h>

#include <uint128.h>
#include <sys/rtai_modbus.h>

#define STACKSIZE 10000

MODULE_LICENSE("GPL");

// sensoren belegung
#define IN_DREHTELLER_SENSOR (1 << 0)
#define IN_BOHRER (1 << 1)
#define IN_PRUEFER (1 << 2)
#define BOHRER_OBEN (1 << 3)
#define BOHRER_UNTEN (1 << 4)
#define DREHTELLER_IN_POS (1 << 5)
#define PRUEFER_NORMALLAGE (1 << 6)

// aktoren
#define BOHRER_AN (1 << 0)
#define DREHTELLER_AN (1 << 1)
#define BOHRER_RUNTER (1 << 2)
#define BOHRER_HOCH (1 << 3)
#define BOHRER_FESTHALTEN (1 << 4)
#define PRUEFER_AN (1 << 5)
#define AUSWERFER_AUSGANG (1 << 6)
#define AUSWERFER_EINGANG (1 << 7)

static RT_TASK task_control;
static RT_TASK task_drehteller;
static RT_TASK task_pruefer;
//static RT_TASK task_bohrer;
//static RT_TASK task_ausgang;

static int error_code;
static int fd_node;

static void control(long x) {
	short val = 0;

	rt_printk("control: task started\n");

	/* Verbindung zum Modbus-Knoten herstellen */
	if ((fd_node = rt_modbus_connect("modbus-node")) == -1) {
		rt_printk("control: modbus_connect failed\n");
		goto fail;
	}

	rt_printk("control: MODBUS communication opened\n");

	while (1) {
		// einlesen der Werte vom Sensor
		if (rt_modbus_get(fd_node, DIGITAL_IN, 0, (unsigned short *) &val))
			goto fail;

		// wenn bit 0 gesetzt ist, wurde ein Objekt erkannt
		if (val & IN_DREHTELLER_SENSOR) {
			//error_code = 0;
			rt_task_resume(&task_drehteller);
		} else {
			// wenn das 0 bit nicht gesetzt ist, nicht drehen (Kein Objekt erkannt)
			if (rt_modbus_set(fd_node, DIGITAL_OUT, 0, 0))
				goto fail;
		}

		// einlesen der Werte vom Sensor
		/*if (rt_modbus_get(fd_node, DIGITAL_IN, 0, (unsigned short *) &val))
			goto fail;

		if (val & PRUEFER_NORMALLAGE){
			//rt_task_resume(&task_pruefer);
		}*/

		/*if (error_code != 0)
		{
			rt_printk("error code = " + error_code);
			goto fail;
		}*/

	}

	fail:
	rt_modbus_disconnect(fd_node);
	rt_printk("control: MODBUS disconnected\n");
	rt_printk("control: task exited\n");
}

static void pruefer(long x) {
	rt_printk("pruefer: task started\n");


	return;
}

static void drehteller(long x) {
	short val = 0;

	rt_printk("drehteller: task started\n");

	// bitmaske an modbus senden
	if (rt_modbus_set(fd_node, DIGITAL_OUT, 0, DREHTELLER_AN)) {
		//error_code = -1;
		return;
	}

	// teller drehen solange bis der teller nicht mehr in position ist
	do {
		rt_sleep(100 * nano2count(1000000));
		if (rt_modbus_get(fd_node, DIGITAL_IN, 0, (unsigned short *) &val)) {
			//error_code = -1;
			return;
		}

		rt_printk("erste do schleife");
	} while ((val & DREHTELLER_IN_POS) == DREHTELLER_IN_POS);

	// 0 an modbus senden und stoppen
	if (rt_modbus_set(fd_node, DIGITAL_OUT, 0, 0)) {
		//error_code = -1;
		return;
	}

	rt_printk("0 gesendet");

	do {
		rt_sleep(100 * nano2count(1000000));
		if (rt_modbus_get(fd_node, DIGITAL_IN, 0, (unsigned short *) &val)) {
			//error_code = -1;
			return;
		}

		rt_printk("zweite do schleife");

	} while ((val & DREHTELLER_IN_POS) != DREHTELLER_IN_POS);

	rt_sleep(100 * nano2count(1000000));

	//error_code = 0;
	return;
}
static void __exit
my_exit(void) {
	stop_rt_timer();
	rt_task_delete(&task_pruefer);
	rt_task_delete(&task_drehteller);
	rt_task_delete(&task_control);

	printk("rtai_example unloaded\n");

}

static int __init
my_init(void) {
	/* variables Timing basierend auf dem CPU-Takt */
	rt_set_oneshot_mode();
	/* Timer starten */
	start_rt_timer(0);
	/* Modbuskommunikation initialisieren */
	modbus_init();

	/* Taskinitialisierung
	 *
	 * &task = Adresse des zu initialisierenden TCB
	 * control = zum Task gehörende Funktion
	 * 0 = Uebergabeparameter an die zum Task gehoerende Funktion (long)
	 * 1024 = Stacksize
	 * 0 = Priorität des Tasks (0 = groesste)
	 * 0 = uses_fpu (Fliesskommaeinheit nicht benutzen); im Praktikum sollte es 0 bleiben
	 * NULL = &signal_handler; Referenz zu einer Fkt., die bei jeder Aktivierung
	 * des Tasks aufgerufen wird, ansonsten NULL
	 *
	 * Achtung: Nach der Initialisierung ist der Task "suspended"!
	 *
	 */
	if (rt_task_init(&task_control, control, 0, STACKSIZE, 0, 0, NULL)) {
		printk("cannot initialize control task\n");
		goto fail;
	}

	if (rt_task_init(&task_drehteller, drehteller, 0, STACKSIZE, 0, 0, NULL)) {
		printk("cannot initialize drehteller task\n");
		goto fail;
	}

	if (rt_task_init(&task_pruefer, pruefer, 0, STACKSIZE, 0, 0, NULL)) {
		printk("cannot initialize pruefer task\n");
		goto fail;
	}

	rt_task_resume(&task_control);
	printk("control task loaded\n");
	return (0);

	fail: stop_rt_timer();
	return (1);
}

module_exit(my_exit)
module_init(my_init)
